"""
Специальный магический метод позволяет экземплярам вашего класса вести себя так,
как будто они функции, тоесть вы сможете «вызывать» их, передавать их в функции,
которые принимают функции в качестве аргументов и так далее. 

__call__(self, [args...])
Позволяет любому экземпляру вашего класса быть вызванным как-будто он функция.
Главным образом это означает, что x() означает то же, что и x.__call__().
Заметьте, __call__ принимает произвольное число аргументов; то есть, вы можете 
определить __call__ так же как любую другую функцию, принимающую столько аргументов,
сколько вам нужно.
"""

class Entity:
    '''Класс, описывающий объект на плоскости. "Вызываемый", чтобы обновить позицию объекта.'''

    def __init__(self, size, x, y):
        self.x, self.y = x, y
        self.size = size

    def __call__(self, x, y):
        '''Изменить положение объекта.'''
        self.x, self.y = x, y

class Callee:
    def __call__(self, *pargs, **kargs):    # Реализует вызов экземпляра
        print('Called:', pargs, kargs)      # Принимает любые аргументы

C = Callee()
print(C(1, 2, 3))                                  # C – вызываемый объект
print(C(1, 2, 3, x=4, y=5))

class Prod:
    def __init__(self, value): # Принимает единственный аргумент
        self.value = value
    def __call__(self, other):
        return self.value * other

x = Prod(2)                     # "Запоминает" 2 в своей области видимости
print(x(3))                            # 3 (передано) * 2 (сохраненное значение)
print(x(4))

